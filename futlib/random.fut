-- | Random number generation inspired by <random> in C++.
--
-- Example usage:
--
-- module dist = uniform_real_distribution f32 minstd_rand
-- let rng = minstd_rand.rng_from_seed [123]
-- let (rng, x) = dist.rand (1,6)

import "/futlib/math"
import "/futlib/array"

-- Quick and dirty hashing to mix in something that looks like entropy.
-- From http://stackoverflow.com/a/12996028
local
let hash(x: i32): i32 =
  let x = ((x >>> 16) ^ x) * 0x45d9f3b
  let x = ((x >>> 16) ^ x) * 0x45d9f3b
  let x = ((x >>> 16) ^ x) in
  x

-- | Low-level modules that act as sources of random numbers in some
-- uniform distribution.
module type rng_engine = {
  -- | A module for the type of integers generated by the engine.
  module int: integral
  -- | The state of the engine.
  type rng

  -- | Initialise an RNG state from a seed.  Even if the seed array is
  -- empty, the resulting RNG should still behave reasonably.  It is
  -- permissible for this function to process the seed array
  -- sequentially, so don't make it too large.
  val rng_from_seed: []i32 -> rng

  -- | Split an RNG state into several states.  Implementations of
  -- this function tend to be cryptographically unsound, so be
  -- careful.
  val split_rng: i32 -> rng -> []rng

  -- | Combine several RNG states into a single state - typically done
  -- with the result of 'split_rng'.
  val join_rng: []rng -> rng

  -- | Generate a single random element, and a new RNG state.
  val rand: rng -> (rng,int.t)

  -- | The minimum value potentially returned by the generator.
  val min: int.t

  -- | The maximum value potentially returned by the generator.
  val max: int.t
}

module type rng_distribution = {
  -- | The type of values produced by this random distribution.
  type t

  -- | The RNG engine state.
  type rng

  -- | The dynamic configuration of the distribution.
  type distribution

  val rand: distribution -> rng -> (rng, t)
}

module linear_congruential_engine (T: integral) (P: {
  val a: T.t
  val c: T.t
  val m: T.t
}): rng_engine with int.t = T.t with rng = T.t = {
  type t = T.t
  type rng = t

  module int = T

  let rand (x: rng): (rng, t) =
    let rng' = (P.a T.* x T.+ P.c) T.%% P.m
    in (rng',rng')

  let rng_from_seed [n] (seed: [n]i32) =
    let seed' =
      loop seed' = T.i32 1 for i < n do
        ((seed' T.>>> T.i32 16) T.^ seed') T.^
        T.i32 (seed[i] ^ 0b1010101010101)
    in (rand seed').1

  let split_rng (n: i32) (x: rng): [n]rng =
    map (\i -> x T.^ T.i32 (hash i)) (iota n)

  let join_rng [n] (xs: [n]rng): rng =
    reduce (T.^) (T.i32 0) xs

  let min = T.i32 0
  let max = P.m
}

-- | The xorshift128+ engine.  Uses two 64-bit words as state.
module xorshift128plus: rng_engine with int.t = u64 = {
  module int = u64
  type rng = (u64,u64)

  -- We currently have a problem where everything that is produced
  -- must be convertible (losslessly) to a i64.  Therefore, we mask
  -- off the highest bit to avoid negative numbers.
  let mask (x: u64) = x & (~(1u64<<63u64))

  let rand ((x,y): rng): (rng, u64) =
    let x = x ^ (x << 23u64)
    let new_x = y
    let new_y = x ^ y ^ (x >> 17u64) ^ (y >> 26u64)
    in ((new_x,new_y), mask (new_y + y))

  let rng_from_seed [n] (seed: [n]i32) =
    loop (a,b) = (1u64,u64.i32 n) for i < n do
      if n % 2 == 0
      then (rand (a^u64.i32 (hash seed[i]),b)).1
      else (rand (a, b^u64.i32 (hash seed[i]))).1

  let split_rng (n: i32) ((x,y): rng): [n]rng =
    map (\i -> let (a,b) = (rand (rng_from_seed [hash (i^n)])).1
               in (rand (x^a,y^b)).1) (iota n)

  let join_rng [n] (xs: [n]rng): rng =
    reduce (\(x1,y1) (x2,y2) -> (x1^x2,y1^y2)) (0u64,0u64) xs

  let min = 0u64
  let max = mask 0xFF_FF_FF_FF_FF_FF_FF_FFu64
}

-- | A 'linear_congruential_engine' producing 'u32' values and
-- initialised with a=48271, c=u and m=2147483647.  This is the same
-- configuration as in C++.
module minstd_rand: rng_engine with int.t = u32 =
  linear_congruential_engine u32 {
    let a = 48271u32
    let c = 0u32
    let m = 2147483647u32
}

-- | A 'linear_congruential_engine' producing 'u32' values and
-- initialised with a=16807, c=u and m=2147483647.  This is the same
-- configuration as in C++.
module minstd_rand0: rng_engine with int.t = u32 =
  linear_congruential_engine u32 {
    let a = 16807u32
    let c = 0u32
    let m = 2147483647u32
}

-- | An engine adaptor that adapts an 'rng_engine' so that the
-- elements are delivered in a different sequence.
--
-- The RNG keeps a buffer of 'k' generated numbers internally, and
-- when requested, returns a randomly selected number within the
-- buffer, replacing it with a value obtained from its base engine.
module shuffle_order_engine
 (K: {val k: i32})
 (I: integral)
 (E: rng_engine with int.t = I.t): rng_engine with int.t = E.int.t = {
  type t = I.t
  module int = I
  type rng = (E.rng, [K.k]t)

  let build_table (rng: E.rng) =
    let xs = replicate K.k (I.i32 0)
    in loop (rng,xs) for i < K.k do
         let (rng,x) = E.rand rng
         in (rng, xs with [i] <- x)

  let rng_from_seed (xs: []i32) =
    let rng = E.rng_from_seed xs
    in build_table rng

  let split_rng (n: i32) ((rng, _): rng): [n]rng =
    map (\rng -> build_table rng) (E.split_rng n rng)

  let join_rng (rngs: []rng) =
    let (rngs', _) = unzip rngs
    in build_table (E.join_rng rngs')

  let rand ((rng,table): rng): (rng, int.t) =
    let (rng,x) = E.rand rng
    let i = i32.i64 (I.to_i64 x) % K.k
    let (rng,y) = E.rand rng
    in ((rng, (copy table) with [i] <- y), table[i])

  let min = E.min
  let max = E.max
}

-- | This uniform integer distribution generates integers in a given
-- range with equal probability for each.
module uniform_int_distribution
   (D: integral)
   (E: rng_engine):
  rng_distribution with t = D.t
                   with rng = E.rng
                   with distribution = (D.t,D.t) = {

  type t = D.t

  let to_D (x: E.int.t) = D.i64 (E.int.to_i64 x)
  let to_E (x: D.t) = E.int.i64 (D.to_i64 x)

  type rng = E.rng
  type distribution = (D.t,D.t) -- Lower and upper bounds.
  let uniform (min: D.t) (max: D.t) = (min,max)

  let rand ((min,max): distribution) (rng: E.rng) =
    let min = to_E min
    let max = to_E max
    let range = max E.int.- min E.int.+ E.int.i32 1
    in if range E.int.<= E.int.i32 0
       then (rng, to_D E.min) -- Avoid infinite loop below.
       else let secure_max = E.max E.int.- E.max E.int.%% range
            let (rng,x) = loop (rng, x) = E.rand rng
                          while x E.int.>= secure_max do E.rand rng
            in (rng, to_D (min E.int.+ x E.int./ (secure_max E.int./ range)))
}

-- | This uniform integer distribution generates floats in a given
-- range with "equal" probability for each.
module uniform_real_distribution (R: real) (E: rng_engine):
  rng_distribution with t = R.t
                   with rng = E.rng
                   with distribution = (R.t,R.t) = {
  let to_D (x: E.int.t) = R.i64 (E.int.to_i64 x)

  type t = R.t
  type rng = E.rng
  type distribution = (t,t) -- Lower and upper bounds.

  let uniform (min: t) (max: t) = (min,max)

  let rand ((min_r,max_r): distribution) (rng: E.rng) =
    let (rng', x) = E.rand rng
    let x' = to_D x R./ to_D E.max
    in (rng', R.(min_r + x' * (max_r - min_r)))
}

module normal_distribution (R: real) (E: rng_engine):
  rng_distribution with t = R.t
                   with rng = E.rng
                   with distribution = {mean:R.t,stddev:R.t} = {
  let to_R (x: E.int.t) = R.i64 (E.int.to_i64 x)

  type t = R.t
  type rng = E.rng
  type distribution = {mean:t,stddev:t}

  let normal (mean: t) (stddev: t) = {mean=mean,stddev=stddev}

  open R

  let rand ({mean,stddev}: distribution) (rng: E.rng) =
    -- Box-Muller where we only use one of the generated points.
    let (rng, u1) = E.rand rng
    let (rng, u2) = E.rand rng
    let u1 = to_R u1 / to_R E.max
    let u2 = to_R u2 / to_R E.max
    let r = sqrt (i32 (-2) * log u1)
    let theta = i32 2 * pi * u2
    in (rng, mean + stddev * (r * cos theta))
}
